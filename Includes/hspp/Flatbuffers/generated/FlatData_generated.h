// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FLATDATA_HEARTHSTONEPP_FLATDATA_H_
#define FLATBUFFERS_GENERATED_FLATDATA_HEARTHSTONEPP_FLATDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace Hearthstonepp {
namespace FlatData {

struct TaskMetaTrait;

struct PlayRequirements;

struct GameTag;

struct Entity;

struct Card;

struct EntityVector;

struct TaskMeta;

struct TaskMetaVector;

struct PlayerSetting;

struct GameStatus;

struct RequireTaskMeta;

struct ResponseMulligan;

struct ResponsePlayCard;

struct ResponsePlayMinion;

struct ResponsePlaySpell;

struct ResponseTarget;

struct GameEndTaskMeta;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskMetaTrait FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;
  uint32_t status_;
  uint8_t userID_;
  int8_t padding0__;  int16_t padding1__;

 public:
  TaskMetaTrait() {
    memset(this, 0, sizeof(TaskMetaTrait));
  }
  TaskMetaTrait(int32_t _id, uint32_t _status, uint8_t _userID)
      : id_(flatbuffers::EndianScalar(_id)),
        status_(flatbuffers::EndianScalar(_status)),
        userID_(flatbuffers::EndianScalar(_userID)),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;    (void)padding1__;
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  uint32_t status() const {
    return flatbuffers::EndianScalar(status_);
  }
  uint8_t userID() const {
    return flatbuffers::EndianScalar(userID_);
  }
};
FLATBUFFERS_STRUCT_END(TaskMetaTrait, 12);

struct PlayRequirements FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY_ = 4,
    VT_VALUE = 6
  };
  int32_t key_() const {
    return GetField<int32_t>(VT_KEY_, 0);
  }
  bool KeyCompareLessThan(const PlayRequirements *o) const {
    return key_() < o->key_();
  }
  int KeyCompareWithValue(int32_t val) const {
    const auto key = key_();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct PlayRequirementsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key_(int32_t key_) {
    fbb_.AddElement<int32_t>(PlayRequirements::VT_KEY_, key_, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(PlayRequirements::VT_VALUE, value, 0);
  }
  explicit PlayRequirementsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayRequirementsBuilder &operator=(const PlayRequirementsBuilder &);
  flatbuffers::Offset<PlayRequirements> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayRequirements>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayRequirements> CreatePlayRequirements(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key_ = 0,
    int32_t value = 0) {
  PlayRequirementsBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key_(key_);
  return builder_.Finish();
}

struct GameTag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY_ = 4,
    VT_VALUE = 6
  };
  int32_t key_() const {
    return GetField<int32_t>(VT_KEY_, 0);
  }
  bool KeyCompareLessThan(const GameTag *o) const {
    return key_() < o->key_();
  }
  int KeyCompareWithValue(int32_t val) const {
    const auto key = key_();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct GameTagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key_(int32_t key_) {
    fbb_.AddElement<int32_t>(GameTag::VT_KEY_, key_, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(GameTag::VT_VALUE, value, 0);
  }
  explicit GameTagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameTagBuilder &operator=(const GameTagBuilder &);
  flatbuffers::Offset<GameTag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameTag>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameTag> CreateGameTag(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key_ = 0,
    int32_t value = 0) {
  GameTagBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key_(key_);
  return builder_.Finish();
}

struct Entity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CARD = 4,
    VT_GAMETAGS = 6
  };
  const Card *card() const {
    return GetPointer<const Card *>(VT_CARD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GameTag>> *gameTags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameTag>> *>(VT_GAMETAGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CARD) &&
           verifier.VerifyTable(card()) &&
           VerifyOffset(verifier, VT_GAMETAGS) &&
           verifier.Verify(gameTags()) &&
           verifier.VerifyVectorOfTables(gameTags()) &&
           verifier.EndTable();
  }
};

struct EntityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_card(flatbuffers::Offset<Card> card) {
    fbb_.AddOffset(Entity::VT_CARD, card);
  }
  void add_gameTags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameTag>>> gameTags) {
    fbb_.AddOffset(Entity::VT_GAMETAGS, gameTags);
  }
  explicit EntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityBuilder &operator=(const EntityBuilder &);
  flatbuffers::Offset<Entity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entity> CreateEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Card> card = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameTag>>> gameTags = 0) {
  EntityBuilder builder_(_fbb);
  builder_.add_gameTags(gameTags);
  builder_.add_card(card);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entity> CreateEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Card> card = 0,
    const std::vector<flatbuffers::Offset<GameTag>> *gameTags = nullptr) {
  return Hearthstonepp::FlatData::CreateEntity(
      _fbb,
      card,
      gameTags ? _fbb.CreateVector<flatbuffers::Offset<GameTag>>(*gameTags) : 0);
}

struct Card FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_RARITY = 6,
    VT_FACTION = 8,
    VT_CARDSET = 10,
    VT_CARDCLASS = 12,
    VT_CARDTYPE = 14,
    VT_RACE = 16,
    VT_NAME = 18,
    VT_TEXT = 20,
    VT_COLLECTIBLE = 22,
    VT_COST = 24,
    VT_ATTACK = 26,
    VT_HEALTH = 28,
    VT_DURABILITY = 30,
    VT_MECHANICS = 32,
    VT_PLAYREQUIREMENTS = 34,
    VT_ENTOURAGES = 36,
    VT_MAXALLOWEDINDECK = 38
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t rarity() const {
    return GetField<int32_t>(VT_RARITY, 0);
  }
  int32_t faction() const {
    return GetField<int32_t>(VT_FACTION, 0);
  }
  int32_t cardSet() const {
    return GetField<int32_t>(VT_CARDSET, 0);
  }
  int32_t cardClass() const {
    return GetField<int32_t>(VT_CARDCLASS, 0);
  }
  int32_t cardType() const {
    return GetField<int32_t>(VT_CARDTYPE, 0);
  }
  int32_t race() const {
    return GetField<int32_t>(VT_RACE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool collectible() const {
    return GetField<uint8_t>(VT_COLLECTIBLE, 0) != 0;
  }
  uint32_t cost() const {
    return GetField<uint32_t>(VT_COST, 0);
  }
  uint32_t attack() const {
    return GetField<uint32_t>(VT_ATTACK, 0);
  }
  uint32_t health() const {
    return GetField<uint32_t>(VT_HEALTH, 0);
  }
  uint32_t durability() const {
    return GetField<uint32_t>(VT_DURABILITY, 0);
  }
  const flatbuffers::Vector<int32_t> *mechanics() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MECHANICS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>> *playRequirements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>> *>(VT_PLAYREQUIREMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *entourages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ENTOURAGES);
  }
  uint32_t maxAllowedInDeck() const {
    return GetField<uint32_t>(VT_MAXALLOWEDINDECK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyField<int32_t>(verifier, VT_RARITY) &&
           VerifyField<int32_t>(verifier, VT_FACTION) &&
           VerifyField<int32_t>(verifier, VT_CARDSET) &&
           VerifyField<int32_t>(verifier, VT_CARDCLASS) &&
           VerifyField<int32_t>(verifier, VT_CARDTYPE) &&
           VerifyField<int32_t>(verifier, VT_RACE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<uint8_t>(verifier, VT_COLLECTIBLE) &&
           VerifyField<uint32_t>(verifier, VT_COST) &&
           VerifyField<uint32_t>(verifier, VT_ATTACK) &&
           VerifyField<uint32_t>(verifier, VT_HEALTH) &&
           VerifyField<uint32_t>(verifier, VT_DURABILITY) &&
           VerifyOffset(verifier, VT_MECHANICS) &&
           verifier.Verify(mechanics()) &&
           VerifyOffset(verifier, VT_PLAYREQUIREMENTS) &&
           verifier.Verify(playRequirements()) &&
           verifier.VerifyVectorOfTables(playRequirements()) &&
           VerifyOffset(verifier, VT_ENTOURAGES) &&
           verifier.Verify(entourages()) &&
           verifier.VerifyVectorOfStrings(entourages()) &&
           VerifyField<uint32_t>(verifier, VT_MAXALLOWEDINDECK) &&
           verifier.EndTable();
  }
};

struct CardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Card::VT_ID, id);
  }
  void add_rarity(int32_t rarity) {
    fbb_.AddElement<int32_t>(Card::VT_RARITY, rarity, 0);
  }
  void add_faction(int32_t faction) {
    fbb_.AddElement<int32_t>(Card::VT_FACTION, faction, 0);
  }
  void add_cardSet(int32_t cardSet) {
    fbb_.AddElement<int32_t>(Card::VT_CARDSET, cardSet, 0);
  }
  void add_cardClass(int32_t cardClass) {
    fbb_.AddElement<int32_t>(Card::VT_CARDCLASS, cardClass, 0);
  }
  void add_cardType(int32_t cardType) {
    fbb_.AddElement<int32_t>(Card::VT_CARDTYPE, cardType, 0);
  }
  void add_race(int32_t race) {
    fbb_.AddElement<int32_t>(Card::VT_RACE, race, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Card::VT_NAME, name);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Card::VT_TEXT, text);
  }
  void add_collectible(bool collectible) {
    fbb_.AddElement<uint8_t>(Card::VT_COLLECTIBLE, static_cast<uint8_t>(collectible), 0);
  }
  void add_cost(uint32_t cost) {
    fbb_.AddElement<uint32_t>(Card::VT_COST, cost, 0);
  }
  void add_attack(uint32_t attack) {
    fbb_.AddElement<uint32_t>(Card::VT_ATTACK, attack, 0);
  }
  void add_health(uint32_t health) {
    fbb_.AddElement<uint32_t>(Card::VT_HEALTH, health, 0);
  }
  void add_durability(uint32_t durability) {
    fbb_.AddElement<uint32_t>(Card::VT_DURABILITY, durability, 0);
  }
  void add_mechanics(flatbuffers::Offset<flatbuffers::Vector<int32_t>> mechanics) {
    fbb_.AddOffset(Card::VT_MECHANICS, mechanics);
  }
  void add_playRequirements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>>> playRequirements) {
    fbb_.AddOffset(Card::VT_PLAYREQUIREMENTS, playRequirements);
  }
  void add_entourages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entourages) {
    fbb_.AddOffset(Card::VT_ENTOURAGES, entourages);
  }
  void add_maxAllowedInDeck(uint32_t maxAllowedInDeck) {
    fbb_.AddElement<uint32_t>(Card::VT_MAXALLOWEDINDECK, maxAllowedInDeck, 0);
  }
  explicit CardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CardBuilder &operator=(const CardBuilder &);
  flatbuffers::Offset<Card> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Card>(end);
    return o;
  }
};

inline flatbuffers::Offset<Card> CreateCard(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t rarity = 0,
    int32_t faction = 0,
    int32_t cardSet = 0,
    int32_t cardClass = 0,
    int32_t cardType = 0,
    int32_t race = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    bool collectible = false,
    uint32_t cost = 0,
    uint32_t attack = 0,
    uint32_t health = 0,
    uint32_t durability = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> mechanics = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>>> playRequirements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entourages = 0,
    uint32_t maxAllowedInDeck = 0) {
  CardBuilder builder_(_fbb);
  builder_.add_maxAllowedInDeck(maxAllowedInDeck);
  builder_.add_entourages(entourages);
  builder_.add_playRequirements(playRequirements);
  builder_.add_mechanics(mechanics);
  builder_.add_durability(durability);
  builder_.add_health(health);
  builder_.add_attack(attack);
  builder_.add_cost(cost);
  builder_.add_text(text);
  builder_.add_name(name);
  builder_.add_race(race);
  builder_.add_cardType(cardType);
  builder_.add_cardClass(cardClass);
  builder_.add_cardSet(cardSet);
  builder_.add_faction(faction);
  builder_.add_rarity(rarity);
  builder_.add_id(id);
  builder_.add_collectible(collectible);
  return builder_.Finish();
}

inline flatbuffers::Offset<Card> CreateCardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t rarity = 0,
    int32_t faction = 0,
    int32_t cardSet = 0,
    int32_t cardClass = 0,
    int32_t cardType = 0,
    int32_t race = 0,
    const char *name = nullptr,
    const char *text = nullptr,
    bool collectible = false,
    uint32_t cost = 0,
    uint32_t attack = 0,
    uint32_t health = 0,
    uint32_t durability = 0,
    const std::vector<int32_t> *mechanics = nullptr,
    const std::vector<flatbuffers::Offset<PlayRequirements>> *playRequirements = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *entourages = nullptr,
    uint32_t maxAllowedInDeck = 0) {
  return Hearthstonepp::FlatData::CreateCard(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      rarity,
      faction,
      cardSet,
      cardClass,
      cardType,
      race,
      name ? _fbb.CreateString(name) : 0,
      text ? _fbb.CreateString(text) : 0,
      collectible,
      cost,
      attack,
      health,
      durability,
      mechanics ? _fbb.CreateVector<int32_t>(*mechanics) : 0,
      playRequirements ? _fbb.CreateVector<flatbuffers::Offset<PlayRequirements>>(*playRequirements) : 0,
      entourages ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*entourages) : 0,
      maxAllowedInDeck);
}

struct EntityVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VECTOR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *vector() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_VECTOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VECTOR) &&
           verifier.Verify(vector()) &&
           verifier.VerifyVectorOfTables(vector()) &&
           verifier.EndTable();
  }
};

struct EntityVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vector(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> vector) {
    fbb_.AddOffset(EntityVector::VT_VECTOR, vector);
  }
  explicit EntityVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityVectorBuilder &operator=(const EntityVectorBuilder &);
  flatbuffers::Offset<EntityVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EntityVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<EntityVector> CreateEntityVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> vector = 0) {
  EntityVectorBuilder builder_(_fbb);
  builder_.add_vector(vector);
  return builder_.Finish();
}

inline flatbuffers::Offset<EntityVector> CreateEntityVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Entity>> *vector = nullptr) {
  return Hearthstonepp::FlatData::CreateEntityVector(
      _fbb,
      vector ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*vector) : 0);
}

struct TaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRAIT = 4,
    VT_BUFFER = 6
  };
  const TaskMetaTrait *trait() const {
    return GetStruct<const TaskMetaTrait *>(VT_TRAIT);
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TaskMetaTrait>(verifier, VT_TRAIT) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.Verify(buffer()) &&
           verifier.EndTable();
  }
};

struct TaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trait(const TaskMetaTrait *trait) {
    fbb_.AddStruct(TaskMeta::VT_TRAIT, trait);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(TaskMeta::VT_BUFFER, buffer);
  }
  explicit TaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaskMetaBuilder &operator=(const TaskMetaBuilder &);
  flatbuffers::Offset<TaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskMeta> CreateTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TaskMetaTrait *trait = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  TaskMetaBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_trait(trait);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskMeta> CreateTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TaskMetaTrait *trait = 0,
    const std::vector<uint8_t> *buffer = nullptr) {
  return Hearthstonepp::FlatData::CreateTaskMeta(
      _fbb,
      trait,
      buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0);
}

struct TaskMetaVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VECTOR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TaskMeta>> *vector() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TaskMeta>> *>(VT_VECTOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VECTOR) &&
           verifier.Verify(vector()) &&
           verifier.VerifyVectorOfTables(vector()) &&
           verifier.EndTable();
  }
};

struct TaskMetaVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vector(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskMeta>>> vector) {
    fbb_.AddOffset(TaskMetaVector::VT_VECTOR, vector);
  }
  explicit TaskMetaVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaskMetaVectorBuilder &operator=(const TaskMetaVectorBuilder &);
  flatbuffers::Offset<TaskMetaVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskMetaVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskMetaVector> CreateTaskMetaVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskMeta>>> vector = 0) {
  TaskMetaVectorBuilder builder_(_fbb);
  builder_.add_vector(vector);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskMetaVector> CreateTaskMetaVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TaskMeta>> *vector = nullptr) {
  return Hearthstonepp::FlatData::CreateTaskMetaVector(
      _fbb,
      vector ? _fbb.CreateVector<flatbuffers::Offset<TaskMeta>>(*vector) : 0);
}

struct PlayerSetting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PLAYER1 = 4,
    VT_PLAYER2 = 6
  };
  const flatbuffers::String *player1() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYER1);
  }
  const flatbuffers::String *player2() const {
    return GetPointer<const flatbuffers::String *>(VT_PLAYER2);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PLAYER1) &&
           verifier.Verify(player1()) &&
           VerifyOffset(verifier, VT_PLAYER2) &&
           verifier.Verify(player2()) &&
           verifier.EndTable();
  }
};

struct PlayerSettingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_player1(flatbuffers::Offset<flatbuffers::String> player1) {
    fbb_.AddOffset(PlayerSetting::VT_PLAYER1, player1);
  }
  void add_player2(flatbuffers::Offset<flatbuffers::String> player2) {
    fbb_.AddOffset(PlayerSetting::VT_PLAYER2, player2);
  }
  explicit PlayerSettingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerSettingBuilder &operator=(const PlayerSettingBuilder &);
  flatbuffers::Offset<PlayerSetting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerSetting>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerSetting> CreatePlayerSetting(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> player1 = 0,
    flatbuffers::Offset<flatbuffers::String> player2 = 0) {
  PlayerSettingBuilder builder_(_fbb);
  builder_.add_player2(player2);
  builder_.add_player1(player1);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerSetting> CreatePlayerSettingDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *player1 = nullptr,
    const char *player2 = nullptr) {
  return Hearthstonepp::FlatData::CreatePlayerSetting(
      _fbb,
      player1 ? _fbb.CreateString(player1) : 0,
      player2 ? _fbb.CreateString(player2) : 0);
}

struct GameStatus FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENTPLAYER = 4,
    VT_OPPONENTPLAYER = 6,
    VT_CURRENTMANA = 8,
    VT_OPPONENTMANA = 10,
    VT_CURRENTHERO = 12,
    VT_OPPONENTHERO = 14,
    VT_CURRENTFIELD = 16,
    VT_CURRENTHAND = 18,
    VT_OPPONENTFIELD = 20,
    VT_NUMOPPONENTHAND = 22,
    VT_NUMCURRENTDECK = 24,
    VT_NUMOPPONENTDECK = 26
  };
  uint8_t currentPlayer() const {
    return GetField<uint8_t>(VT_CURRENTPLAYER, 0);
  }
  uint8_t opponentPlayer() const {
    return GetField<uint8_t>(VT_OPPONENTPLAYER, 0);
  }
  uint8_t currentMana() const {
    return GetField<uint8_t>(VT_CURRENTMANA, 0);
  }
  uint8_t opponentMana() const {
    return GetField<uint8_t>(VT_OPPONENTMANA, 0);
  }
  const Entity *currentHero() const {
    return GetPointer<const Entity *>(VT_CURRENTHERO);
  }
  const Entity *opponentHero() const {
    return GetPointer<const Entity *>(VT_OPPONENTHERO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *currentField() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_CURRENTFIELD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *currentHand() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_CURRENTHAND);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *opponentField() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_OPPONENTFIELD);
  }
  uint8_t numOpponentHand() const {
    return GetField<uint8_t>(VT_NUMOPPONENTHAND, 0);
  }
  uint8_t numCurrentDeck() const {
    return GetField<uint8_t>(VT_NUMCURRENTDECK, 0);
  }
  uint8_t numOpponentDeck() const {
    return GetField<uint8_t>(VT_NUMOPPONENTDECK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CURRENTPLAYER) &&
           VerifyField<uint8_t>(verifier, VT_OPPONENTPLAYER) &&
           VerifyField<uint8_t>(verifier, VT_CURRENTMANA) &&
           VerifyField<uint8_t>(verifier, VT_OPPONENTMANA) &&
           VerifyOffset(verifier, VT_CURRENTHERO) &&
           verifier.VerifyTable(currentHero()) &&
           VerifyOffset(verifier, VT_OPPONENTHERO) &&
           verifier.VerifyTable(opponentHero()) &&
           VerifyOffset(verifier, VT_CURRENTFIELD) &&
           verifier.Verify(currentField()) &&
           verifier.VerifyVectorOfTables(currentField()) &&
           VerifyOffset(verifier, VT_CURRENTHAND) &&
           verifier.Verify(currentHand()) &&
           verifier.VerifyVectorOfTables(currentHand()) &&
           VerifyOffset(verifier, VT_OPPONENTFIELD) &&
           verifier.Verify(opponentField()) &&
           verifier.VerifyVectorOfTables(opponentField()) &&
           VerifyField<uint8_t>(verifier, VT_NUMOPPONENTHAND) &&
           VerifyField<uint8_t>(verifier, VT_NUMCURRENTDECK) &&
           VerifyField<uint8_t>(verifier, VT_NUMOPPONENTDECK) &&
           verifier.EndTable();
  }
};

struct GameStatusBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currentPlayer(uint8_t currentPlayer) {
    fbb_.AddElement<uint8_t>(GameStatus::VT_CURRENTPLAYER, currentPlayer, 0);
  }
  void add_opponentPlayer(uint8_t opponentPlayer) {
    fbb_.AddElement<uint8_t>(GameStatus::VT_OPPONENTPLAYER, opponentPlayer, 0);
  }
  void add_currentMana(uint8_t currentMana) {
    fbb_.AddElement<uint8_t>(GameStatus::VT_CURRENTMANA, currentMana, 0);
  }
  void add_opponentMana(uint8_t opponentMana) {
    fbb_.AddElement<uint8_t>(GameStatus::VT_OPPONENTMANA, opponentMana, 0);
  }
  void add_currentHero(flatbuffers::Offset<Entity> currentHero) {
    fbb_.AddOffset(GameStatus::VT_CURRENTHERO, currentHero);
  }
  void add_opponentHero(flatbuffers::Offset<Entity> opponentHero) {
    fbb_.AddOffset(GameStatus::VT_OPPONENTHERO, opponentHero);
  }
  void add_currentField(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentField) {
    fbb_.AddOffset(GameStatus::VT_CURRENTFIELD, currentField);
  }
  void add_currentHand(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentHand) {
    fbb_.AddOffset(GameStatus::VT_CURRENTHAND, currentHand);
  }
  void add_opponentField(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> opponentField) {
    fbb_.AddOffset(GameStatus::VT_OPPONENTFIELD, opponentField);
  }
  void add_numOpponentHand(uint8_t numOpponentHand) {
    fbb_.AddElement<uint8_t>(GameStatus::VT_NUMOPPONENTHAND, numOpponentHand, 0);
  }
  void add_numCurrentDeck(uint8_t numCurrentDeck) {
    fbb_.AddElement<uint8_t>(GameStatus::VT_NUMCURRENTDECK, numCurrentDeck, 0);
  }
  void add_numOpponentDeck(uint8_t numOpponentDeck) {
    fbb_.AddElement<uint8_t>(GameStatus::VT_NUMOPPONENTDECK, numOpponentDeck, 0);
  }
  explicit GameStatusBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameStatusBuilder &operator=(const GameStatusBuilder &);
  flatbuffers::Offset<GameStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameStatus>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameStatus> CreateGameStatus(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t currentPlayer = 0,
    uint8_t opponentPlayer = 0,
    uint8_t currentMana = 0,
    uint8_t opponentMana = 0,
    flatbuffers::Offset<Entity> currentHero = 0,
    flatbuffers::Offset<Entity> opponentHero = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentField = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentHand = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> opponentField = 0,
    uint8_t numOpponentHand = 0,
    uint8_t numCurrentDeck = 0,
    uint8_t numOpponentDeck = 0) {
  GameStatusBuilder builder_(_fbb);
  builder_.add_opponentField(opponentField);
  builder_.add_currentHand(currentHand);
  builder_.add_currentField(currentField);
  builder_.add_opponentHero(opponentHero);
  builder_.add_currentHero(currentHero);
  builder_.add_numOpponentDeck(numOpponentDeck);
  builder_.add_numCurrentDeck(numCurrentDeck);
  builder_.add_numOpponentHand(numOpponentHand);
  builder_.add_opponentMana(opponentMana);
  builder_.add_currentMana(currentMana);
  builder_.add_opponentPlayer(opponentPlayer);
  builder_.add_currentPlayer(currentPlayer);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameStatus> CreateGameStatusDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t currentPlayer = 0,
    uint8_t opponentPlayer = 0,
    uint8_t currentMana = 0,
    uint8_t opponentMana = 0,
    flatbuffers::Offset<Entity> currentHero = 0,
    flatbuffers::Offset<Entity> opponentHero = 0,
    const std::vector<flatbuffers::Offset<Entity>> *currentField = nullptr,
    const std::vector<flatbuffers::Offset<Entity>> *currentHand = nullptr,
    const std::vector<flatbuffers::Offset<Entity>> *opponentField = nullptr,
    uint8_t numOpponentHand = 0,
    uint8_t numCurrentDeck = 0,
    uint8_t numOpponentDeck = 0) {
  return Hearthstonepp::FlatData::CreateGameStatus(
      _fbb,
      currentPlayer,
      opponentPlayer,
      currentMana,
      opponentMana,
      currentHero,
      opponentHero,
      currentField ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*currentField) : 0,
      currentHand ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*currentHand) : 0,
      opponentField ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*opponentField) : 0,
      numOpponentHand,
      numCurrentDeck,
      numOpponentDeck);
}

struct RequireTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REQUIRED = 4
  };
  int32_t required() const {
    return GetField<int32_t>(VT_REQUIRED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REQUIRED) &&
           verifier.EndTable();
  }
};

struct RequireTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_required(int32_t required) {
    fbb_.AddElement<int32_t>(RequireTaskMeta::VT_REQUIRED, required, 0);
  }
  explicit RequireTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequireTaskMetaBuilder &operator=(const RequireTaskMetaBuilder &);
  flatbuffers::Offset<RequireTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequireTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequireTaskMeta> CreateRequireTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t required = 0) {
  RequireTaskMetaBuilder builder_(_fbb);
  builder_.add_required(required);
  return builder_.Finish();
}

struct ResponseMulligan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MULLIGAN = 4
  };
  const flatbuffers::Vector<uint8_t> *mulligan() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MULLIGAN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULLIGAN) &&
           verifier.Verify(mulligan()) &&
           verifier.EndTable();
  }
};

struct ResponseMulliganBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mulligan(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mulligan) {
    fbb_.AddOffset(ResponseMulligan::VT_MULLIGAN, mulligan);
  }
  explicit ResponseMulliganBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseMulliganBuilder &operator=(const ResponseMulliganBuilder &);
  flatbuffers::Offset<ResponseMulligan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponseMulligan>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponseMulligan> CreateResponseMulligan(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mulligan = 0) {
  ResponseMulliganBuilder builder_(_fbb);
  builder_.add_mulligan(mulligan);
  return builder_.Finish();
}

inline flatbuffers::Offset<ResponseMulligan> CreateResponseMulliganDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *mulligan = nullptr) {
  return Hearthstonepp::FlatData::CreateResponseMulligan(
      _fbb,
      mulligan ? _fbb.CreateVector<uint8_t>(*mulligan) : 0);
}

struct ResponsePlayCard FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CARDINDEX = 4
  };
  uint8_t cardIndex() const {
    return GetField<uint8_t>(VT_CARDINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CARDINDEX) &&
           verifier.EndTable();
  }
};

struct ResponsePlayCardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cardIndex(uint8_t cardIndex) {
    fbb_.AddElement<uint8_t>(ResponsePlayCard::VT_CARDINDEX, cardIndex, 0);
  }
  explicit ResponsePlayCardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponsePlayCardBuilder &operator=(const ResponsePlayCardBuilder &);
  flatbuffers::Offset<ResponsePlayCard> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponsePlayCard>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponsePlayCard> CreateResponsePlayCard(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t cardIndex = 0) {
  ResponsePlayCardBuilder builder_(_fbb);
  builder_.add_cardIndex(cardIndex);
  return builder_.Finish();
}

struct ResponsePlayMinion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION = 4
  };
  uint8_t position() const {
    return GetField<uint8_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct ResponsePlayMinionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(uint8_t position) {
    fbb_.AddElement<uint8_t>(ResponsePlayMinion::VT_POSITION, position, 0);
  }
  explicit ResponsePlayMinionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponsePlayMinionBuilder &operator=(const ResponsePlayMinionBuilder &);
  flatbuffers::Offset<ResponsePlayMinion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponsePlayMinion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponsePlayMinion> CreateResponsePlayMinion(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t position = 0) {
  ResponsePlayMinionBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct ResponsePlaySpell FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TARGETTYPE = 4,
    VT_POSITION = 6
  };
  uint8_t targetType() const {
    return GetField<uint8_t>(VT_TARGETTYPE, 0);
  }
  uint8_t position() const {
    return GetField<uint8_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TARGETTYPE) &&
           VerifyField<uint8_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct ResponsePlaySpellBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_targetType(uint8_t targetType) {
    fbb_.AddElement<uint8_t>(ResponsePlaySpell::VT_TARGETTYPE, targetType, 0);
  }
  void add_position(uint8_t position) {
    fbb_.AddElement<uint8_t>(ResponsePlaySpell::VT_POSITION, position, 0);
  }
  explicit ResponsePlaySpellBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponsePlaySpellBuilder &operator=(const ResponsePlaySpellBuilder &);
  flatbuffers::Offset<ResponsePlaySpell> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponsePlaySpell>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponsePlaySpell> CreateResponsePlaySpell(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t targetType = 0,
    uint8_t position = 0) {
  ResponsePlaySpellBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_targetType(targetType);
  return builder_.Finish();
}

struct ResponseTarget FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6
  };
  uint8_t src() const {
    return GetField<uint8_t>(VT_SRC, 0);
  }
  uint8_t dst() const {
    return GetField<uint8_t>(VT_DST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SRC) &&
           VerifyField<uint8_t>(verifier, VT_DST) &&
           verifier.EndTable();
  }
};

struct ResponseTargetBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(uint8_t src) {
    fbb_.AddElement<uint8_t>(ResponseTarget::VT_SRC, src, 0);
  }
  void add_dst(uint8_t dst) {
    fbb_.AddElement<uint8_t>(ResponseTarget::VT_DST, dst, 0);
  }
  explicit ResponseTargetBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResponseTargetBuilder &operator=(const ResponseTargetBuilder &);
  flatbuffers::Offset<ResponseTarget> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResponseTarget>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResponseTarget> CreateResponseTarget(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t src = 0,
    uint8_t dst = 0) {
  ResponseTargetBuilder builder_(_fbb);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct GameEndTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WINNERID = 4
  };
  const flatbuffers::String *winnerID() const {
    return GetPointer<const flatbuffers::String *>(VT_WINNERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WINNERID) &&
           verifier.Verify(winnerID()) &&
           verifier.EndTable();
  }
};

struct GameEndTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_winnerID(flatbuffers::Offset<flatbuffers::String> winnerID) {
    fbb_.AddOffset(GameEndTaskMeta::VT_WINNERID, winnerID);
  }
  explicit GameEndTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameEndTaskMetaBuilder &operator=(const GameEndTaskMetaBuilder &);
  flatbuffers::Offset<GameEndTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameEndTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameEndTaskMeta> CreateGameEndTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> winnerID = 0) {
  GameEndTaskMetaBuilder builder_(_fbb);
  builder_.add_winnerID(winnerID);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameEndTaskMeta> CreateGameEndTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *winnerID = nullptr) {
  return Hearthstonepp::FlatData::CreateGameEndTaskMeta(
      _fbb,
      winnerID ? _fbb.CreateString(winnerID) : 0);
}

}  // namespace FlatData
}  // namespace Hearthstonepp

#endif  // FLATBUFFERS_GENERATED_FLATDATA_HEARTHSTONEPP_FLATDATA_H_
