// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_METADATA_HEARTHSTONEPP_FLATDATA_H_
#define FLATBUFFERS_GENERATED_METADATA_HEARTHSTONEPP_FLATDATA_H_

#include "flatbuffers/flatbuffers.h"

namespace Hearthstonepp {
namespace FlatData {

struct TaskMetaTrait;

struct PlayRequirements;

struct GameTag;

struct Entity;

struct Card;

struct TaskMeta;

struct TaskMetaVector;

struct RequireTaskMeta;

struct PlayerSettingTaskMeta;

struct DrawTaskMeta;

struct BriefTaskMeta;

struct RequireMulliganTaskMeta;

struct ModifyManaTaskMeta;

struct RequireSummonMinionTaskMeta;

struct SummonMinionTaskMeta;

struct ModifyHealthTaskMeta;

struct CombatTaskMeta;

struct RequireTargetingTaskMeta;

struct GameEndTaskMeta;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) TaskMetaTrait FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t id_;
  uint32_t status_;
  uint8_t userID_;
  int8_t padding0__;  int16_t padding1__;

 public:
  TaskMetaTrait() {
    memset(this, 0, sizeof(TaskMetaTrait));
  }
  TaskMetaTrait(int32_t _id, uint32_t _status, uint8_t _userID)
      : id_(flatbuffers::EndianScalar(_id)),
        status_(flatbuffers::EndianScalar(_status)),
        userID_(flatbuffers::EndianScalar(_userID)),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;    (void)padding1__;
  }
  int32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  uint32_t status() const {
    return flatbuffers::EndianScalar(status_);
  }
  uint8_t userID() const {
    return flatbuffers::EndianScalar(userID_);
  }
};
FLATBUFFERS_STRUCT_END(TaskMetaTrait, 12);

struct PlayRequirements FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY_ = 4,
    VT_VALUE = 6
  };
  int32_t key_() const {
    return GetField<int32_t>(VT_KEY_, 0);
  }
  bool KeyCompareLessThan(const PlayRequirements *o) const {
    return key_() < o->key_();
  }
  int KeyCompareWithValue(int32_t val) const {
    const auto key = key_();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct PlayRequirementsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key_(int32_t key_) {
    fbb_.AddElement<int32_t>(PlayRequirements::VT_KEY_, key_, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(PlayRequirements::VT_VALUE, value, 0);
  }
  explicit PlayRequirementsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayRequirementsBuilder &operator=(const PlayRequirementsBuilder &);
  flatbuffers::Offset<PlayRequirements> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayRequirements>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayRequirements> CreatePlayRequirements(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key_ = 0,
    int32_t value = 0) {
  PlayRequirementsBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key_(key_);
  return builder_.Finish();
}

struct GameTag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY_ = 4,
    VT_VALUE = 6
  };
  int32_t key_() const {
    return GetField<int32_t>(VT_KEY_, 0);
  }
  bool KeyCompareLessThan(const GameTag *o) const {
    return key_() < o->key_();
  }
  int KeyCompareWithValue(int32_t val) const {
    const auto key = key_();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  int32_t value() const {
    return GetField<int32_t>(VT_VALUE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEY_) &&
           VerifyField<int32_t>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
};

struct GameTagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key_(int32_t key_) {
    fbb_.AddElement<int32_t>(GameTag::VT_KEY_, key_, 0);
  }
  void add_value(int32_t value) {
    fbb_.AddElement<int32_t>(GameTag::VT_VALUE, value, 0);
  }
  explicit GameTagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameTagBuilder &operator=(const GameTagBuilder &);
  flatbuffers::Offset<GameTag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameTag>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameTag> CreateGameTag(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t key_ = 0,
    int32_t value = 0) {
  GameTagBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key_(key_);
  return builder_.Finish();
}

struct Entity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CARD = 4,
    VT_GAMETAGS = 6
  };
  const Card *card() const {
    return GetPointer<const Card *>(VT_CARD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GameTag>> *gameTags() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GameTag>> *>(VT_GAMETAGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CARD) &&
           verifier.VerifyTable(card()) &&
           VerifyOffset(verifier, VT_GAMETAGS) &&
           verifier.Verify(gameTags()) &&
           verifier.VerifyVectorOfTables(gameTags()) &&
           verifier.EndTable();
  }
};

struct EntityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_card(flatbuffers::Offset<Card> card) {
    fbb_.AddOffset(Entity::VT_CARD, card);
  }
  void add_gameTags(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameTag>>> gameTags) {
    fbb_.AddOffset(Entity::VT_GAMETAGS, gameTags);
  }
  explicit EntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EntityBuilder &operator=(const EntityBuilder &);
  flatbuffers::Offset<Entity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entity> CreateEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Card> card = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GameTag>>> gameTags = 0) {
  EntityBuilder builder_(_fbb);
  builder_.add_gameTags(gameTags);
  builder_.add_card(card);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entity> CreateEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Card> card = 0,
    const std::vector<flatbuffers::Offset<GameTag>> *gameTags = nullptr) {
  return Hearthstonepp::FlatData::CreateEntity(
      _fbb,
      card,
      gameTags ? _fbb.CreateVector<flatbuffers::Offset<GameTag>>(*gameTags) : 0);
}

struct Card FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_RARITY = 6,
    VT_FACTION = 8,
    VT_CARDSET = 10,
    VT_CARDCLASS = 12,
    VT_CARDTYPE = 14,
    VT_RACE = 16,
    VT_NAME = 18,
    VT_TEXT = 20,
    VT_COLLECTIBLE = 22,
    VT_COST = 24,
    VT_ATTACK = 26,
    VT_HEALTH = 28,
    VT_DURABILITY = 30,
    VT_MECHANICS = 32,
    VT_PLAYREQUIREMENTS = 34,
    VT_ENTOURAGES = 36,
    VT_MAXALLOWEDINDECK = 38
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t rarity() const {
    return GetField<int32_t>(VT_RARITY, 0);
  }
  int32_t faction() const {
    return GetField<int32_t>(VT_FACTION, 0);
  }
  int32_t cardSet() const {
    return GetField<int32_t>(VT_CARDSET, 0);
  }
  int32_t cardClass() const {
    return GetField<int32_t>(VT_CARDCLASS, 0);
  }
  int32_t cardType() const {
    return GetField<int32_t>(VT_CARDTYPE, 0);
  }
  int32_t race() const {
    return GetField<int32_t>(VT_RACE, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  bool collectible() const {
    return GetField<uint8_t>(VT_COLLECTIBLE, 0) != 0;
  }
  uint32_t cost() const {
    return GetField<uint32_t>(VT_COST, 0);
  }
  uint32_t attack() const {
    return GetField<uint32_t>(VT_ATTACK, 0);
  }
  uint32_t health() const {
    return GetField<uint32_t>(VT_HEALTH, 0);
  }
  uint32_t durability() const {
    return GetField<uint32_t>(VT_DURABILITY, 0);
  }
  const flatbuffers::Vector<int32_t> *mechanics() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MECHANICS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>> *playRequirements() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>> *>(VT_PLAYREQUIREMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *entourages() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ENTOURAGES);
  }
  uint32_t maxAllowedInDeck() const {
    return GetField<uint32_t>(VT_MAXALLOWEDINDECK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.Verify(id()) &&
           VerifyField<int32_t>(verifier, VT_RARITY) &&
           VerifyField<int32_t>(verifier, VT_FACTION) &&
           VerifyField<int32_t>(verifier, VT_CARDSET) &&
           VerifyField<int32_t>(verifier, VT_CARDCLASS) &&
           VerifyField<int32_t>(verifier, VT_CARDTYPE) &&
           VerifyField<int32_t>(verifier, VT_RACE) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyOffset(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<uint8_t>(verifier, VT_COLLECTIBLE) &&
           VerifyField<uint32_t>(verifier, VT_COST) &&
           VerifyField<uint32_t>(verifier, VT_ATTACK) &&
           VerifyField<uint32_t>(verifier, VT_HEALTH) &&
           VerifyField<uint32_t>(verifier, VT_DURABILITY) &&
           VerifyOffset(verifier, VT_MECHANICS) &&
           verifier.Verify(mechanics()) &&
           VerifyOffset(verifier, VT_PLAYREQUIREMENTS) &&
           verifier.Verify(playRequirements()) &&
           verifier.VerifyVectorOfTables(playRequirements()) &&
           VerifyOffset(verifier, VT_ENTOURAGES) &&
           verifier.Verify(entourages()) &&
           verifier.VerifyVectorOfStrings(entourages()) &&
           VerifyField<uint32_t>(verifier, VT_MAXALLOWEDINDECK) &&
           verifier.EndTable();
  }
};

struct CardBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(Card::VT_ID, id);
  }
  void add_rarity(int32_t rarity) {
    fbb_.AddElement<int32_t>(Card::VT_RARITY, rarity, 0);
  }
  void add_faction(int32_t faction) {
    fbb_.AddElement<int32_t>(Card::VT_FACTION, faction, 0);
  }
  void add_cardSet(int32_t cardSet) {
    fbb_.AddElement<int32_t>(Card::VT_CARDSET, cardSet, 0);
  }
  void add_cardClass(int32_t cardClass) {
    fbb_.AddElement<int32_t>(Card::VT_CARDCLASS, cardClass, 0);
  }
  void add_cardType(int32_t cardType) {
    fbb_.AddElement<int32_t>(Card::VT_CARDTYPE, cardType, 0);
  }
  void add_race(int32_t race) {
    fbb_.AddElement<int32_t>(Card::VT_RACE, race, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Card::VT_NAME, name);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(Card::VT_TEXT, text);
  }
  void add_collectible(bool collectible) {
    fbb_.AddElement<uint8_t>(Card::VT_COLLECTIBLE, static_cast<uint8_t>(collectible), 0);
  }
  void add_cost(uint32_t cost) {
    fbb_.AddElement<uint32_t>(Card::VT_COST, cost, 0);
  }
  void add_attack(uint32_t attack) {
    fbb_.AddElement<uint32_t>(Card::VT_ATTACK, attack, 0);
  }
  void add_health(uint32_t health) {
    fbb_.AddElement<uint32_t>(Card::VT_HEALTH, health, 0);
  }
  void add_durability(uint32_t durability) {
    fbb_.AddElement<uint32_t>(Card::VT_DURABILITY, durability, 0);
  }
  void add_mechanics(flatbuffers::Offset<flatbuffers::Vector<int32_t>> mechanics) {
    fbb_.AddOffset(Card::VT_MECHANICS, mechanics);
  }
  void add_playRequirements(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>>> playRequirements) {
    fbb_.AddOffset(Card::VT_PLAYREQUIREMENTS, playRequirements);
  }
  void add_entourages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entourages) {
    fbb_.AddOffset(Card::VT_ENTOURAGES, entourages);
  }
  void add_maxAllowedInDeck(uint32_t maxAllowedInDeck) {
    fbb_.AddElement<uint32_t>(Card::VT_MAXALLOWEDINDECK, maxAllowedInDeck, 0);
  }
  explicit CardBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CardBuilder &operator=(const CardBuilder &);
  flatbuffers::Offset<Card> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Card>(end);
    return o;
  }
};

inline flatbuffers::Offset<Card> CreateCard(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t rarity = 0,
    int32_t faction = 0,
    int32_t cardSet = 0,
    int32_t cardClass = 0,
    int32_t cardType = 0,
    int32_t race = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    bool collectible = false,
    uint32_t cost = 0,
    uint32_t attack = 0,
    uint32_t health = 0,
    uint32_t durability = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> mechanics = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PlayRequirements>>> playRequirements = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> entourages = 0,
    uint32_t maxAllowedInDeck = 0) {
  CardBuilder builder_(_fbb);
  builder_.add_maxAllowedInDeck(maxAllowedInDeck);
  builder_.add_entourages(entourages);
  builder_.add_playRequirements(playRequirements);
  builder_.add_mechanics(mechanics);
  builder_.add_durability(durability);
  builder_.add_health(health);
  builder_.add_attack(attack);
  builder_.add_cost(cost);
  builder_.add_text(text);
  builder_.add_name(name);
  builder_.add_race(race);
  builder_.add_cardType(cardType);
  builder_.add_cardClass(cardClass);
  builder_.add_cardSet(cardSet);
  builder_.add_faction(faction);
  builder_.add_rarity(rarity);
  builder_.add_id(id);
  builder_.add_collectible(collectible);
  return builder_.Finish();
}

inline flatbuffers::Offset<Card> CreateCardDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t rarity = 0,
    int32_t faction = 0,
    int32_t cardSet = 0,
    int32_t cardClass = 0,
    int32_t cardType = 0,
    int32_t race = 0,
    const char *name = nullptr,
    const char *text = nullptr,
    bool collectible = false,
    uint32_t cost = 0,
    uint32_t attack = 0,
    uint32_t health = 0,
    uint32_t durability = 0,
    const std::vector<int32_t> *mechanics = nullptr,
    const std::vector<flatbuffers::Offset<PlayRequirements>> *playRequirements = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *entourages = nullptr,
    uint32_t maxAllowedInDeck = 0) {
  return Hearthstonepp::FlatData::CreateCard(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      rarity,
      faction,
      cardSet,
      cardClass,
      cardType,
      race,
      name ? _fbb.CreateString(name) : 0,
      text ? _fbb.CreateString(text) : 0,
      collectible,
      cost,
      attack,
      health,
      durability,
      mechanics ? _fbb.CreateVector<int32_t>(*mechanics) : 0,
      playRequirements ? _fbb.CreateVector<flatbuffers::Offset<PlayRequirements>>(*playRequirements) : 0,
      entourages ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*entourages) : 0,
      maxAllowedInDeck);
}

struct TaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRAIT = 4,
    VT_BUFFER = 6
  };
  const TaskMetaTrait *trait() const {
    return GetStruct<const TaskMetaTrait *>(VT_TRAIT);
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<TaskMetaTrait>(verifier, VT_TRAIT) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.Verify(buffer()) &&
           verifier.EndTable();
  }
};

struct TaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_trait(const TaskMetaTrait *trait) {
    fbb_.AddStruct(TaskMeta::VT_TRAIT, trait);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(TaskMeta::VT_BUFFER, buffer);
  }
  explicit TaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaskMetaBuilder &operator=(const TaskMetaBuilder &);
  flatbuffers::Offset<TaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskMeta> CreateTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TaskMetaTrait *trait = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  TaskMetaBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_trait(trait);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskMeta> CreateTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const TaskMetaTrait *trait = 0,
    const std::vector<uint8_t> *buffer = nullptr) {
  return Hearthstonepp::FlatData::CreateTaskMeta(
      _fbb,
      trait,
      buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0);
}

struct TaskMetaVector FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VECTOR = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<TaskMeta>> *vector() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<TaskMeta>> *>(VT_VECTOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VECTOR) &&
           verifier.Verify(vector()) &&
           verifier.VerifyVectorOfTables(vector()) &&
           verifier.EndTable();
  }
};

struct TaskMetaVectorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vector(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskMeta>>> vector) {
    fbb_.AddOffset(TaskMetaVector::VT_VECTOR, vector);
  }
  explicit TaskMetaVectorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TaskMetaVectorBuilder &operator=(const TaskMetaVectorBuilder &);
  flatbuffers::Offset<TaskMetaVector> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TaskMetaVector>(end);
    return o;
  }
};

inline flatbuffers::Offset<TaskMetaVector> CreateTaskMetaVector(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<TaskMeta>>> vector = 0) {
  TaskMetaVectorBuilder builder_(_fbb);
  builder_.add_vector(vector);
  return builder_.Finish();
}

inline flatbuffers::Offset<TaskMetaVector> CreateTaskMetaVectorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<TaskMeta>> *vector = nullptr) {
  return Hearthstonepp::FlatData::CreateTaskMetaVector(
      _fbb,
      vector ? _fbb.CreateVector<flatbuffers::Offset<TaskMeta>>(*vector) : 0);
}

struct RequireTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_REQUIRED = 4
  };
  int32_t required() const {
    return GetField<int32_t>(VT_REQUIRED, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REQUIRED) &&
           verifier.EndTable();
  }
};

struct RequireTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_required(int32_t required) {
    fbb_.AddElement<int32_t>(RequireTaskMeta::VT_REQUIRED, required, 0);
  }
  explicit RequireTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequireTaskMetaBuilder &operator=(const RequireTaskMetaBuilder &);
  flatbuffers::Offset<RequireTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequireTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequireTaskMeta> CreateRequireTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t required = 0) {
  RequireTaskMetaBuilder builder_(_fbb);
  builder_.add_required(required);
  return builder_.Finish();
}

struct PlayerSettingTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FIRSTID = 4,
    VT_SECONDID = 6
  };
  const flatbuffers::String *firstID() const {
    return GetPointer<const flatbuffers::String *>(VT_FIRSTID);
  }
  const flatbuffers::String *secondID() const {
    return GetPointer<const flatbuffers::String *>(VT_SECONDID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FIRSTID) &&
           verifier.Verify(firstID()) &&
           VerifyOffset(verifier, VT_SECONDID) &&
           verifier.Verify(secondID()) &&
           verifier.EndTable();
  }
};

struct PlayerSettingTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_firstID(flatbuffers::Offset<flatbuffers::String> firstID) {
    fbb_.AddOffset(PlayerSettingTaskMeta::VT_FIRSTID, firstID);
  }
  void add_secondID(flatbuffers::Offset<flatbuffers::String> secondID) {
    fbb_.AddOffset(PlayerSettingTaskMeta::VT_SECONDID, secondID);
  }
  explicit PlayerSettingTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PlayerSettingTaskMetaBuilder &operator=(const PlayerSettingTaskMetaBuilder &);
  flatbuffers::Offset<PlayerSettingTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PlayerSettingTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<PlayerSettingTaskMeta> CreatePlayerSettingTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> firstID = 0,
    flatbuffers::Offset<flatbuffers::String> secondID = 0) {
  PlayerSettingTaskMetaBuilder builder_(_fbb);
  builder_.add_secondID(secondID);
  builder_.add_firstID(firstID);
  return builder_.Finish();
}

inline flatbuffers::Offset<PlayerSettingTaskMeta> CreatePlayerSettingTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *firstID = nullptr,
    const char *secondID = nullptr) {
  return Hearthstonepp::FlatData::CreatePlayerSettingTaskMeta(
      _fbb,
      firstID ? _fbb.CreateString(firstID) : 0,
      secondID ? _fbb.CreateString(secondID) : 0);
}

struct DrawTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUMDRAW = 4,
    VT_NUMEXHAUSTED = 6,
    VT_NUMHEARTS = 8,
    VT_NUMOVERDRAW = 10,
    VT_BURNT = 12
  };
  uint8_t numDraw() const {
    return GetField<uint8_t>(VT_NUMDRAW, 0);
  }
  uint8_t numExhausted() const {
    return GetField<uint8_t>(VT_NUMEXHAUSTED, 0);
  }
  uint8_t numHearts() const {
    return GetField<uint8_t>(VT_NUMHEARTS, 0);
  }
  uint8_t numOverdraw() const {
    return GetField<uint8_t>(VT_NUMOVERDRAW, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *burnt() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_BURNT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NUMDRAW) &&
           VerifyField<uint8_t>(verifier, VT_NUMEXHAUSTED) &&
           VerifyField<uint8_t>(verifier, VT_NUMHEARTS) &&
           VerifyField<uint8_t>(verifier, VT_NUMOVERDRAW) &&
           VerifyOffset(verifier, VT_BURNT) &&
           verifier.Verify(burnt()) &&
           verifier.VerifyVectorOfTables(burnt()) &&
           verifier.EndTable();
  }
};

struct DrawTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numDraw(uint8_t numDraw) {
    fbb_.AddElement<uint8_t>(DrawTaskMeta::VT_NUMDRAW, numDraw, 0);
  }
  void add_numExhausted(uint8_t numExhausted) {
    fbb_.AddElement<uint8_t>(DrawTaskMeta::VT_NUMEXHAUSTED, numExhausted, 0);
  }
  void add_numHearts(uint8_t numHearts) {
    fbb_.AddElement<uint8_t>(DrawTaskMeta::VT_NUMHEARTS, numHearts, 0);
  }
  void add_numOverdraw(uint8_t numOverdraw) {
    fbb_.AddElement<uint8_t>(DrawTaskMeta::VT_NUMOVERDRAW, numOverdraw, 0);
  }
  void add_burnt(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> burnt) {
    fbb_.AddOffset(DrawTaskMeta::VT_BURNT, burnt);
  }
  explicit DrawTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DrawTaskMetaBuilder &operator=(const DrawTaskMetaBuilder &);
  flatbuffers::Offset<DrawTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DrawTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<DrawTaskMeta> CreateDrawTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t numDraw = 0,
    uint8_t numExhausted = 0,
    uint8_t numHearts = 0,
    uint8_t numOverdraw = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> burnt = 0) {
  DrawTaskMetaBuilder builder_(_fbb);
  builder_.add_burnt(burnt);
  builder_.add_numOverdraw(numOverdraw);
  builder_.add_numHearts(numHearts);
  builder_.add_numExhausted(numExhausted);
  builder_.add_numDraw(numDraw);
  return builder_.Finish();
}

inline flatbuffers::Offset<DrawTaskMeta> CreateDrawTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t numDraw = 0,
    uint8_t numExhausted = 0,
    uint8_t numHearts = 0,
    uint8_t numOverdraw = 0,
    const std::vector<flatbuffers::Offset<Entity>> *burnt = nullptr) {
  return Hearthstonepp::FlatData::CreateDrawTaskMeta(
      _fbb,
      numDraw,
      numExhausted,
      numHearts,
      numOverdraw,
      burnt ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*burnt) : 0);
}

struct BriefTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CURRENTPLAYER = 4,
    VT_OPPONENTPLAYER = 6,
    VT_CURRENTMANA = 8,
    VT_OPPONENTMANA = 10,
    VT_CURRENTHERO = 12,
    VT_OPPONENTHERO = 14,
    VT_CURRENTFIELD = 16,
    VT_CURRENTHAND = 18,
    VT_OPPONENTFIELD = 20,
    VT_NUMOPPONENTHAND = 22,
    VT_NUMCURRENTDECK = 24,
    VT_NUMOPPONENTDECK = 26,
    VT_CURRENTATTACKED = 28,
    VT_OPPONENTATTACKED = 30
  };
  uint8_t currentPlayer() const {
    return GetField<uint8_t>(VT_CURRENTPLAYER, 0);
  }
  uint8_t opponentPlayer() const {
    return GetField<uint8_t>(VT_OPPONENTPLAYER, 0);
  }
  uint8_t currentMana() const {
    return GetField<uint8_t>(VT_CURRENTMANA, 0);
  }
  uint8_t opponentMana() const {
    return GetField<uint8_t>(VT_OPPONENTMANA, 0);
  }
  const Entity *currentHero() const {
    return GetPointer<const Entity *>(VT_CURRENTHERO);
  }
  const Entity *opponentHero() const {
    return GetPointer<const Entity *>(VT_OPPONENTHERO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *currentField() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_CURRENTFIELD);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *currentHand() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_CURRENTHAND);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *opponentField() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_OPPONENTFIELD);
  }
  uint8_t numOpponentHand() const {
    return GetField<uint8_t>(VT_NUMOPPONENTHAND, 0);
  }
  uint8_t numCurrentDeck() const {
    return GetField<uint8_t>(VT_NUMCURRENTDECK, 0);
  }
  uint8_t numOpponentDeck() const {
    return GetField<uint8_t>(VT_NUMOPPONENTDECK, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *currentAttacked() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_CURRENTATTACKED);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Entity>> *opponentAttacked() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Entity>> *>(VT_OPPONENTATTACKED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CURRENTPLAYER) &&
           VerifyField<uint8_t>(verifier, VT_OPPONENTPLAYER) &&
           VerifyField<uint8_t>(verifier, VT_CURRENTMANA) &&
           VerifyField<uint8_t>(verifier, VT_OPPONENTMANA) &&
           VerifyOffset(verifier, VT_CURRENTHERO) &&
           verifier.VerifyTable(currentHero()) &&
           VerifyOffset(verifier, VT_OPPONENTHERO) &&
           verifier.VerifyTable(opponentHero()) &&
           VerifyOffset(verifier, VT_CURRENTFIELD) &&
           verifier.Verify(currentField()) &&
           verifier.VerifyVectorOfTables(currentField()) &&
           VerifyOffset(verifier, VT_CURRENTHAND) &&
           verifier.Verify(currentHand()) &&
           verifier.VerifyVectorOfTables(currentHand()) &&
           VerifyOffset(verifier, VT_OPPONENTFIELD) &&
           verifier.Verify(opponentField()) &&
           verifier.VerifyVectorOfTables(opponentField()) &&
           VerifyField<uint8_t>(verifier, VT_NUMOPPONENTHAND) &&
           VerifyField<uint8_t>(verifier, VT_NUMCURRENTDECK) &&
           VerifyField<uint8_t>(verifier, VT_NUMOPPONENTDECK) &&
           VerifyOffset(verifier, VT_CURRENTATTACKED) &&
           verifier.Verify(currentAttacked()) &&
           verifier.VerifyVectorOfTables(currentAttacked()) &&
           VerifyOffset(verifier, VT_OPPONENTATTACKED) &&
           verifier.Verify(opponentAttacked()) &&
           verifier.VerifyVectorOfTables(opponentAttacked()) &&
           verifier.EndTable();
  }
};

struct BriefTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_currentPlayer(uint8_t currentPlayer) {
    fbb_.AddElement<uint8_t>(BriefTaskMeta::VT_CURRENTPLAYER, currentPlayer, 0);
  }
  void add_opponentPlayer(uint8_t opponentPlayer) {
    fbb_.AddElement<uint8_t>(BriefTaskMeta::VT_OPPONENTPLAYER, opponentPlayer, 0);
  }
  void add_currentMana(uint8_t currentMana) {
    fbb_.AddElement<uint8_t>(BriefTaskMeta::VT_CURRENTMANA, currentMana, 0);
  }
  void add_opponentMana(uint8_t opponentMana) {
    fbb_.AddElement<uint8_t>(BriefTaskMeta::VT_OPPONENTMANA, opponentMana, 0);
  }
  void add_currentHero(flatbuffers::Offset<Entity> currentHero) {
    fbb_.AddOffset(BriefTaskMeta::VT_CURRENTHERO, currentHero);
  }
  void add_opponentHero(flatbuffers::Offset<Entity> opponentHero) {
    fbb_.AddOffset(BriefTaskMeta::VT_OPPONENTHERO, opponentHero);
  }
  void add_currentField(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentField) {
    fbb_.AddOffset(BriefTaskMeta::VT_CURRENTFIELD, currentField);
  }
  void add_currentHand(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentHand) {
    fbb_.AddOffset(BriefTaskMeta::VT_CURRENTHAND, currentHand);
  }
  void add_opponentField(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> opponentField) {
    fbb_.AddOffset(BriefTaskMeta::VT_OPPONENTFIELD, opponentField);
  }
  void add_numOpponentHand(uint8_t numOpponentHand) {
    fbb_.AddElement<uint8_t>(BriefTaskMeta::VT_NUMOPPONENTHAND, numOpponentHand, 0);
  }
  void add_numCurrentDeck(uint8_t numCurrentDeck) {
    fbb_.AddElement<uint8_t>(BriefTaskMeta::VT_NUMCURRENTDECK, numCurrentDeck, 0);
  }
  void add_numOpponentDeck(uint8_t numOpponentDeck) {
    fbb_.AddElement<uint8_t>(BriefTaskMeta::VT_NUMOPPONENTDECK, numOpponentDeck, 0);
  }
  void add_currentAttacked(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentAttacked) {
    fbb_.AddOffset(BriefTaskMeta::VT_CURRENTATTACKED, currentAttacked);
  }
  void add_opponentAttacked(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> opponentAttacked) {
    fbb_.AddOffset(BriefTaskMeta::VT_OPPONENTATTACKED, opponentAttacked);
  }
  explicit BriefTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BriefTaskMetaBuilder &operator=(const BriefTaskMetaBuilder &);
  flatbuffers::Offset<BriefTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BriefTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<BriefTaskMeta> CreateBriefTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t currentPlayer = 0,
    uint8_t opponentPlayer = 0,
    uint8_t currentMana = 0,
    uint8_t opponentMana = 0,
    flatbuffers::Offset<Entity> currentHero = 0,
    flatbuffers::Offset<Entity> opponentHero = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentField = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentHand = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> opponentField = 0,
    uint8_t numOpponentHand = 0,
    uint8_t numCurrentDeck = 0,
    uint8_t numOpponentDeck = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> currentAttacked = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Entity>>> opponentAttacked = 0) {
  BriefTaskMetaBuilder builder_(_fbb);
  builder_.add_opponentAttacked(opponentAttacked);
  builder_.add_currentAttacked(currentAttacked);
  builder_.add_opponentField(opponentField);
  builder_.add_currentHand(currentHand);
  builder_.add_currentField(currentField);
  builder_.add_opponentHero(opponentHero);
  builder_.add_currentHero(currentHero);
  builder_.add_numOpponentDeck(numOpponentDeck);
  builder_.add_numCurrentDeck(numCurrentDeck);
  builder_.add_numOpponentHand(numOpponentHand);
  builder_.add_opponentMana(opponentMana);
  builder_.add_currentMana(currentMana);
  builder_.add_opponentPlayer(opponentPlayer);
  builder_.add_currentPlayer(currentPlayer);
  return builder_.Finish();
}

inline flatbuffers::Offset<BriefTaskMeta> CreateBriefTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t currentPlayer = 0,
    uint8_t opponentPlayer = 0,
    uint8_t currentMana = 0,
    uint8_t opponentMana = 0,
    flatbuffers::Offset<Entity> currentHero = 0,
    flatbuffers::Offset<Entity> opponentHero = 0,
    const std::vector<flatbuffers::Offset<Entity>> *currentField = nullptr,
    const std::vector<flatbuffers::Offset<Entity>> *currentHand = nullptr,
    const std::vector<flatbuffers::Offset<Entity>> *opponentField = nullptr,
    uint8_t numOpponentHand = 0,
    uint8_t numCurrentDeck = 0,
    uint8_t numOpponentDeck = 0,
    const std::vector<flatbuffers::Offset<Entity>> *currentAttacked = nullptr,
    const std::vector<flatbuffers::Offset<Entity>> *opponentAttacked = nullptr) {
  return Hearthstonepp::FlatData::CreateBriefTaskMeta(
      _fbb,
      currentPlayer,
      opponentPlayer,
      currentMana,
      opponentMana,
      currentHero,
      opponentHero,
      currentField ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*currentField) : 0,
      currentHand ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*currentHand) : 0,
      opponentField ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*opponentField) : 0,
      numOpponentHand,
      numCurrentDeck,
      numOpponentDeck,
      currentAttacked ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*currentAttacked) : 0,
      opponentAttacked ? _fbb.CreateVector<flatbuffers::Offset<Entity>>(*opponentAttacked) : 0);
}

struct RequireMulliganTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MULLIGAN = 4
  };
  const flatbuffers::Vector<uint8_t> *mulligan() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MULLIGAN);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULLIGAN) &&
           verifier.Verify(mulligan()) &&
           verifier.EndTable();
  }
};

struct RequireMulliganTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mulligan(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mulligan) {
    fbb_.AddOffset(RequireMulliganTaskMeta::VT_MULLIGAN, mulligan);
  }
  explicit RequireMulliganTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequireMulliganTaskMetaBuilder &operator=(const RequireMulliganTaskMetaBuilder &);
  flatbuffers::Offset<RequireMulliganTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequireMulliganTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequireMulliganTaskMeta> CreateRequireMulliganTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mulligan = 0) {
  RequireMulliganTaskMetaBuilder builder_(_fbb);
  builder_.add_mulligan(mulligan);
  return builder_.Finish();
}

inline flatbuffers::Offset<RequireMulliganTaskMeta> CreateRequireMulliganTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *mulligan = nullptr) {
  return Hearthstonepp::FlatData::CreateRequireMulliganTaskMeta(
      _fbb,
      mulligan ? _fbb.CreateVector<uint8_t>(*mulligan) : 0);
}

struct ModifyManaTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUMMODE = 4,
    VT_MANAMODE = 6,
    VT_OBJECT = 8,
    VT_RESULT = 10
  };
  uint8_t numMode() const {
    return GetField<uint8_t>(VT_NUMMODE, 0);
  }
  uint8_t manaMode() const {
    return GetField<uint8_t>(VT_MANAMODE, 0);
  }
  uint8_t object() const {
    return GetField<uint8_t>(VT_OBJECT, 0);
  }
  uint8_t result() const {
    return GetField<uint8_t>(VT_RESULT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NUMMODE) &&
           VerifyField<uint8_t>(verifier, VT_MANAMODE) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT) &&
           VerifyField<uint8_t>(verifier, VT_RESULT) &&
           verifier.EndTable();
  }
};

struct ModifyManaTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numMode(uint8_t numMode) {
    fbb_.AddElement<uint8_t>(ModifyManaTaskMeta::VT_NUMMODE, numMode, 0);
  }
  void add_manaMode(uint8_t manaMode) {
    fbb_.AddElement<uint8_t>(ModifyManaTaskMeta::VT_MANAMODE, manaMode, 0);
  }
  void add_object(uint8_t object) {
    fbb_.AddElement<uint8_t>(ModifyManaTaskMeta::VT_OBJECT, object, 0);
  }
  void add_result(uint8_t result) {
    fbb_.AddElement<uint8_t>(ModifyManaTaskMeta::VT_RESULT, result, 0);
  }
  explicit ModifyManaTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModifyManaTaskMetaBuilder &operator=(const ModifyManaTaskMetaBuilder &);
  flatbuffers::Offset<ModifyManaTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModifyManaTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModifyManaTaskMeta> CreateModifyManaTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t numMode = 0,
    uint8_t manaMode = 0,
    uint8_t object = 0,
    uint8_t result = 0) {
  ModifyManaTaskMetaBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_object(object);
  builder_.add_manaMode(manaMode);
  builder_.add_numMode(numMode);
  return builder_.Finish();
}

struct RequireSummonMinionTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CARDINDEX = 4,
    VT_POSITION = 6
  };
  uint8_t cardIndex() const {
    return GetField<uint8_t>(VT_CARDINDEX, 0);
  }
  uint8_t position() const {
    return GetField<uint8_t>(VT_POSITION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CARDINDEX) &&
           VerifyField<uint8_t>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct RequireSummonMinionTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_cardIndex(uint8_t cardIndex) {
    fbb_.AddElement<uint8_t>(RequireSummonMinionTaskMeta::VT_CARDINDEX, cardIndex, 0);
  }
  void add_position(uint8_t position) {
    fbb_.AddElement<uint8_t>(RequireSummonMinionTaskMeta::VT_POSITION, position, 0);
  }
  explicit RequireSummonMinionTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequireSummonMinionTaskMetaBuilder &operator=(const RequireSummonMinionTaskMetaBuilder &);
  flatbuffers::Offset<RequireSummonMinionTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequireSummonMinionTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequireSummonMinionTaskMeta> CreateRequireSummonMinionTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t cardIndex = 0,
    uint8_t position = 0) {
  RequireSummonMinionTaskMetaBuilder builder_(_fbb);
  builder_.add_position(position);
  builder_.add_cardIndex(cardIndex);
  return builder_.Finish();
}

struct SummonMinionTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENTITY = 4,
    VT_INDEX = 6
  };
  const Entity *entity() const {
    return GetPointer<const Entity *>(VT_ENTITY);
  }
  uint8_t index() const {
    return GetField<uint8_t>(VT_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY) &&
           verifier.VerifyTable(entity()) &&
           VerifyField<uint8_t>(verifier, VT_INDEX) &&
           verifier.EndTable();
  }
};

struct SummonMinionTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity(flatbuffers::Offset<Entity> entity) {
    fbb_.AddOffset(SummonMinionTaskMeta::VT_ENTITY, entity);
  }
  void add_index(uint8_t index) {
    fbb_.AddElement<uint8_t>(SummonMinionTaskMeta::VT_INDEX, index, 0);
  }
  explicit SummonMinionTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SummonMinionTaskMetaBuilder &operator=(const SummonMinionTaskMetaBuilder &);
  flatbuffers::Offset<SummonMinionTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SummonMinionTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<SummonMinionTaskMeta> CreateSummonMinionTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Entity> entity = 0,
    uint8_t index = 0) {
  SummonMinionTaskMetaBuilder builder_(_fbb);
  builder_.add_entity(entity);
  builder_.add_index(index);
  return builder_.Finish();
}

struct ModifyHealthTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ENTITY = 4,
    VT_DAMAGE = 6,
    VT_HURTED = 8,
    VT_ISEXHAUSTED = 10
  };
  const Entity *entity() const {
    return GetPointer<const Entity *>(VT_ENTITY);
  }
  uint8_t damage() const {
    return GetField<uint8_t>(VT_DAMAGE, 0);
  }
  uint8_t hurted() const {
    return GetField<uint8_t>(VT_HURTED, 0);
  }
  bool isExhausted() const {
    return GetField<uint8_t>(VT_ISEXHAUSTED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTITY) &&
           verifier.VerifyTable(entity()) &&
           VerifyField<uint8_t>(verifier, VT_DAMAGE) &&
           VerifyField<uint8_t>(verifier, VT_HURTED) &&
           VerifyField<uint8_t>(verifier, VT_ISEXHAUSTED) &&
           verifier.EndTable();
  }
};

struct ModifyHealthTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity(flatbuffers::Offset<Entity> entity) {
    fbb_.AddOffset(ModifyHealthTaskMeta::VT_ENTITY, entity);
  }
  void add_damage(uint8_t damage) {
    fbb_.AddElement<uint8_t>(ModifyHealthTaskMeta::VT_DAMAGE, damage, 0);
  }
  void add_hurted(uint8_t hurted) {
    fbb_.AddElement<uint8_t>(ModifyHealthTaskMeta::VT_HURTED, hurted, 0);
  }
  void add_isExhausted(bool isExhausted) {
    fbb_.AddElement<uint8_t>(ModifyHealthTaskMeta::VT_ISEXHAUSTED, static_cast<uint8_t>(isExhausted), 0);
  }
  explicit ModifyHealthTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModifyHealthTaskMetaBuilder &operator=(const ModifyHealthTaskMetaBuilder &);
  flatbuffers::Offset<ModifyHealthTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ModifyHealthTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<ModifyHealthTaskMeta> CreateModifyHealthTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Entity> entity = 0,
    uint8_t damage = 0,
    uint8_t hurted = 0,
    bool isExhausted = false) {
  ModifyHealthTaskMetaBuilder builder_(_fbb);
  builder_.add_entity(entity);
  builder_.add_isExhausted(isExhausted);
  builder_.add_hurted(hurted);
  builder_.add_damage(damage);
  return builder_.Finish();
}

struct CombatTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6
  };
  const Entity *src() const {
    return GetPointer<const Entity *>(VT_SRC);
  }
  const Entity *dst() const {
    return GetPointer<const Entity *>(VT_DST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SRC) &&
           verifier.VerifyTable(src()) &&
           VerifyOffset(verifier, VT_DST) &&
           verifier.VerifyTable(dst()) &&
           verifier.EndTable();
  }
};

struct CombatTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(flatbuffers::Offset<Entity> src) {
    fbb_.AddOffset(CombatTaskMeta::VT_SRC, src);
  }
  void add_dst(flatbuffers::Offset<Entity> dst) {
    fbb_.AddOffset(CombatTaskMeta::VT_DST, dst);
  }
  explicit CombatTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CombatTaskMetaBuilder &operator=(const CombatTaskMetaBuilder &);
  flatbuffers::Offset<CombatTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CombatTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<CombatTaskMeta> CreateCombatTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Entity> src = 0,
    flatbuffers::Offset<Entity> dst = 0) {
  CombatTaskMetaBuilder builder_(_fbb);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct RequireTargetingTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SRC = 4,
    VT_DST = 6
  };
  uint8_t src() const {
    return GetField<uint8_t>(VT_SRC, 0);
  }
  uint8_t dst() const {
    return GetField<uint8_t>(VT_DST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SRC) &&
           VerifyField<uint8_t>(verifier, VT_DST) &&
           verifier.EndTable();
  }
};

struct RequireTargetingTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src(uint8_t src) {
    fbb_.AddElement<uint8_t>(RequireTargetingTaskMeta::VT_SRC, src, 0);
  }
  void add_dst(uint8_t dst) {
    fbb_.AddElement<uint8_t>(RequireTargetingTaskMeta::VT_DST, dst, 0);
  }
  explicit RequireTargetingTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequireTargetingTaskMetaBuilder &operator=(const RequireTargetingTaskMetaBuilder &);
  flatbuffers::Offset<RequireTargetingTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RequireTargetingTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<RequireTargetingTaskMeta> CreateRequireTargetingTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t src = 0,
    uint8_t dst = 0) {
  RequireTargetingTaskMetaBuilder builder_(_fbb);
  builder_.add_dst(dst);
  builder_.add_src(src);
  return builder_.Finish();
}

struct GameEndTaskMeta FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_WINNERID = 4
  };
  const flatbuffers::String *winnerID() const {
    return GetPointer<const flatbuffers::String *>(VT_WINNERID);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_WINNERID) &&
           verifier.Verify(winnerID()) &&
           verifier.EndTable();
  }
};

struct GameEndTaskMetaBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_winnerID(flatbuffers::Offset<flatbuffers::String> winnerID) {
    fbb_.AddOffset(GameEndTaskMeta::VT_WINNERID, winnerID);
  }
  explicit GameEndTaskMetaBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GameEndTaskMetaBuilder &operator=(const GameEndTaskMetaBuilder &);
  flatbuffers::Offset<GameEndTaskMeta> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GameEndTaskMeta>(end);
    return o;
  }
};

inline flatbuffers::Offset<GameEndTaskMeta> CreateGameEndTaskMeta(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> winnerID = 0) {
  GameEndTaskMetaBuilder builder_(_fbb);
  builder_.add_winnerID(winnerID);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameEndTaskMeta> CreateGameEndTaskMetaDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *winnerID = nullptr) {
  return Hearthstonepp::FlatData::CreateGameEndTaskMeta(
      _fbb,
      winnerID ? _fbb.CreateString(winnerID) : 0);
}

}  // namespace FlatData
}  // namespace Hearthstonepp

#endif  // FLATBUFFERS_GENERATED_METADATA_HEARTHSTONEPP_FLATDATA_H_
